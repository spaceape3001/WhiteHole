////////////////////////////////////////////////////////////////////////////////
//
//  YOUR QUILL
//
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <yq/keywords.hpp>
#include <yq/post/Post.hpp>
#include <atomic>
#include <cassert>
#include <cstdint>
#include <string_view>
#include <vector>
#include <tbb/spin_rw_mutex.h>

namespace yq { class Cleanup; }

namespace yq::post {

    /*! \brief Sender/Reciever of posts
    
        The mailer is responsible for couriering posts to/from another mailer.  
        
        \note All sorts of synonyms were mulled through, including Exchange, 
        Office, Box, Courier, etc... Going with mailer, for now.
    */
    class Mailer {
    public:

        class Connection;
        class Filter;
        
        #if 0
        //! Stops the "handle" instead queues up the messages
        void            hold(pull_t);
        
        //! Stops the actual dispatch, queues up messages
        void            hold(push_t);
        #endif

        //! Subscribes this message box to receive messages from the sender
        Connection&     subscribe(pull_t, Mailer& sender);

        /*! Subscribes the other message box to our messages
        
            \note Subscribing/unsubscribing is *NOT* currently thread-safe, 
                though publishing & recieving ought to be.
        
            \param[in] recipient    Mailer recipient
            \return Connection reference
        */
        Connection&     subscribe(push_t, Mailer& recipient);


        //! Unsubscribes this mailbox from our messages
        void            unsubscribe(pull_t, Mailer& sender);

        void            unsubscribe(push_t, Mailer& recipient);

        //! Unsubscribes both ways with specified mailbox
        void            unsubscribe(Mailer& other);
    
        //! Unsubscribes ALL 
        void            unsubscribe(all_t);

        //! Unsubscribes all recipients 
        void            unsubscribe(push_t, all_t);

        //! Unsubscribes all senders 
        void            unsubscribe(pull_t, all_t);
    
        virtual std::string_view    name() const;
        virtual std::string_view    description() const;

        //! Total number of events generated by this producer
        size_t          published_count() const;
        size_t          received_count() const;

        class Capture;
        
        //! Captures *ALL* messages sent on thread until this object is destroyed
        Capture         capture(all_t);

        #if 0
        //  pending feature idea....
        //! This is *NOT* thread-safe call, do it at initialization time.  (ie create & set before use)
        void            set_cleanup(Cleanup*);
        #endif

    protected:
        Mailer();
        ~Mailer();

        void            publish(PostPtr);
        
        template <SomePost M>
        const M&        publish(Post* msg, ref_t)
        {
            assert(msg);
            publish(msg);
            return *msg;
        }
        
        virtual void    receive(PostPtr){}

    private:
        friend class Post;
        struct Thread;
        struct Postage;

        static Thread&                  thread();
        
        struct Queue {
            std::vector<Connection*>    connections;
            std::atomic<size_t>         usage{0};
            //std::vector<PostCPtr>    messages;
            //mutable tbb::spin_rw_mutex  mutex;
            //std::atomic_flag            hold;
            
            void        _add(Connection*);
            void        _forget(Connection*);
        };
        
        Queue               m_rx, m_tx;
        //Cleanup*        m_cleanup   = nullptr;
        
        std::atomic<int>    m_balance{0};   //< Balance of sent message that still exist

        Mailer(const Mailer&) = delete;
        Mailer(Mailer&&) = delete;
        Mailer& operator=(const Mailer&) = delete;
        Mailer& operator=(Mailer&&) = delete;
        
        void    _receive(PostPtr);
        void    _send(PostPtr);
    };
    
    class Mailer::Capture {
    public:
    
        Capture();
        ~Capture();
        
        Capture(Capture&&);
        Capture& operator=(Capture&&);
    
    private:
        friend class Mailer;
        Capture(Mailer*);
        Mailer*      m_box = nullptr;
        
        Capture(const Capture&) = delete;
        Capture& operator=(const Capture&) = delete;
    };

    class Mailer::Filter {
    public:
        virtual bool    accept(const Post&) const = 0;
        virtual ~Filter(){}
    };
    
    class Mailer::Connection {
    public:
    
        // add filters here....
    
    private:
        friend class Mailer;
        
        Connection(Mailer* tx, Mailer* rx);
        ~Connection();
        
        Mailer*                    m_sender    = nullptr;
        Mailer*                    m_recipient = nullptr;
        std::vector<Filter*>    m_filters;
        
        bool                    accept(const Post&) const;
    };
}
